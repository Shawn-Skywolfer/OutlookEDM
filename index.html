<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Outlook EDM 制作专家 v2.3 - 优化切片体验</title>
    <!-- 加载 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 加载 React 核心库 -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- 加载 Babel 用于在线解析 JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        
        .preview-body { background-color: #ffffff; line-height: normal; }
        .preview-canvas { box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25); background: white; }
        .edm-table td { line-height: 0; font-size: 0; }
        .edm-table img { display: block; vertical-align: top; }
        
        /* PS 风格切片编辑器 */
        .ps-slicer-viewport {
            position: relative;
            cursor: crosshair;
            min-height: 100%;
            padding: 2rem 4rem; /* 增加内边距 */
        }
        
        .ps-slicer-container {
            position: relative;
            user-select: none;
            background: #f1f5f9;
            margin: 0 auto;
            max-width: 800px; /* 限制最大宽度 */
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }
        
        .ps-slice {
            position: absolute;
            left: 0;
            right: 0;
            border: 1px solid #00a8ff;
            background: rgba(0, 168, 255, 0.08);
            pointer-events: auto;
            transition: background 0.1s;
        }
        .ps-slice:hover {
            background: rgba(255, 159, 26, 0.15);
            border-color: #ff9f1a;
        }
        .ps-slice.deleting {
            background: rgba(239, 68, 68, 0.2) !important;
            border-color: #ef4444 !important;
            cursor: pointer;
        }

        .ps-slice-tag {
            position: absolute;
            top: -1px;
            left: -1px;
            background: #00a8ff;
            color: white;
            font-size: 9px;
            padding: 0px 4px;
            height: 14px;
            line-height: 14px;
            font-family: sans-serif;
            pointer-events: none;
            z-index: 10;
        }
        .ps-slice:hover .ps-slice-tag { background: #ff9f1a; }
        .ps-slice.deleting .ps-slice-tag { background: #ef4444; }

        .ps-slice.selected {
            border: 2px solid #2563eb;
            background: rgba(37, 99, 235, 0.1);
            z-index: 20;
        }

        .preview-image-selected {
            box-shadow: 0 0 0 3px #2563eb;
            z-index: 10;
            position: relative;
        }

        .preview-image-unselected {
            border: 3px dashed #ff9f1a;
            box-sizing: border-box;
        }

        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #cbd5e1;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            border-radius: 8px;
            padding: 4px;
            z-index: 100;
            min-width: 120px;
        }
        .context-menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            font-size: 13px;
            color: #334155;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.1s;
        }
        .context-menu-item:hover {
            background: #f1f5f9;
            color: #0f172a;
        }
        .context-menu-item.danger {
            color: #ef4444;
        }
        .context-menu-item.danger:hover {
            background: #fef2f2;
            color: #dc2626;
        }

        .context-menu-item.disabled {
            color: #94a3b8;
            cursor: not-allowed;
        }
        .context-menu-item.disabled:hover {
            background: transparent;
            color: #94a3b8;
        }

        /* 绘制中的全宽虚线反馈 */
        .ps-drawing-overlay {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px dashed #ff9f1a;
            border-bottom: 1px dashed #ff9f1a;
            background: rgba(255, 159, 26, 0.1);
            pointer-events: none;
            z-index: 20;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 font-sans">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        // 内联 SVG 图标
        const Icon = ({ name, size = 18, className = "" }) => {
            const icons = {
                Upload: <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>,
                Trash2: <path d="M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2M10 11v6M14 11v6"/>,
                Layout: <path d="M3 3h18v18H3zM3 9h18M9 21V9"/>,
                Eye: <React.Fragment><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/></React.Fragment>,
                Settings: <React.Fragment><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.1a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></React.Fragment>,
                Mail: <React.Fragment><rect width="20" height="16" x="2" y="4" rx="2"/><path d="m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7"/></React.Fragment>,
                Send: <React.Fragment><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></React.Fragment>,
                Scissors: <React.Fragment><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M20 4 8.12 15.88M14.47 14.48 20 20M8.12 8.12 12 12"/></React.Fragment>,
                Undo: <path d="M3 7V2h5M2 2l4.9 4.9C8.3 5.4 10 4.5 12 4.5c4.1 0 7.5 3.4 7.5 7.5s-3.4 7.5-7.5 7.5c-2.8 0-5.3-1.5-6.6-3.8"/>,
                Redo: <path d="M21 7V2h-5M22 2l-4.9 4.9c-1.4-1.5-3.1-2.4-5.1-2.4-4.1 0-7.5 3.4-7.5 7.5s3.4 7.5 7.5 7.5c2.8 0 5.3-1.5 6.6-3.8"/>,
                Crop: <path d="M6 2v14a2 2 0 0 0 2 2h14M18 22V8a2 2 0 0 0-2-2H2"/>,
                Check: <path d="M20 6 9 17l-5-5"/>,
                MoveVertical: <path d="m8 18 4 4 4-4M8 6l4-4 4 4M12 2v20"/>
            };
            return (
                <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                    {icons[name] || null}
                </svg>
            );
        };

        const App = () => {
            const [mode, setMode] = useState('slices'); 
            const [images, setImages] = useState([]);
            const [longImage, setLongImage] = useState(null); 
            const [targetWidthCm, setTargetWidthCm] = useState(15);
            const [isExporting, setIsExporting] = useState(false);
            const [mailInfo, setMailInfo] = useState({ subject: 'Outlook EDM 邮件' });
            
            const [editorTool, setEditorTool] = useState('slice'); 
            const [sliceMarkers, setSliceMarkers] = useState([]);
            const [history, setHistory] = useState([]);
            const [redoStack, setRedoStack] = useState([]);
            const [isDrawing, setIsDrawing] = useState(false);
            const [currentDraw, setCurrentDraw] = useState(null);
            const [drawConstraint, setDrawConstraint] = useState({ min: 0, max: 0 });
            const [resizeTarget, setResizeTarget] = useState(null); // { type: 'dual'|'top'|'bottom', upperId, lowerId, sliceId, constraintMin, constraintMax }
            const [selectedSliceIds, setSelectedSliceIds] = useState([]);
            const [contextMenu, setContextMenu] = useState(null); // { x, y, visible, disabled }
            const [isPointerLocked, setIsPointerLocked] = useState(false);

            const dragItem = useRef(null);
            const dragOverItem = useRef(null);
            const longImageContainerRef = useRef(null); // 图片所在的容器
            const longImageImgRef = useRef(null); // 图片元素本身

            const CM_TO_PX = 37.8; 
            const SNAP_THRESHOLD = 12; 

            // 拖拽排序处理
            const handleDragStart = (e, index) => {
                dragItem.current = index;
                e.dataTransfer.effectAllowed = "move";
                // 拖拽时自动选中该图片
                setSelectedSliceIds([images[index].id]);
            };

            const handleDragEnter = (e, index) => {
                const dragIndex = dragItem.current;
                if (dragIndex === null || dragIndex === index) return;

                const newImages = [...images];
                const draggedImage = newImages[dragIndex];
                newImages.splice(dragIndex, 1);
                newImages.splice(index, 0, draggedImage);
                
                setImages(newImages);
                dragItem.current = index;
            };

            const handleDragEnd = () => {
                dragItem.current = null;
                dragOverItem.current = null;
            };

            const pushHistory = useCallback((newMarkers) => {
                setHistory(prev => [...prev, sliceMarkers]);
                setSliceMarkers(newMarkers);
                setRedoStack([]);
            }, [sliceMarkers]);

            const undo = () => {
                if (history.length === 0) return;
                const prev = history[history.length - 1];
                setRedoStack(p => [...p, sliceMarkers]);
                setSliceMarkers(prev);
                setHistory(history.slice(0, -1));
            };

            const redo = () => {
                if (redoStack.length === 0) return;
                const next = redoStack[redoStack.length - 1];
                setHistory(p => [...p, sliceMarkers]);
                setSliceMarkers(next);
                setRedoStack(redoStack.slice(0, -1));
            };

            const handleFileUpload = (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;

                if (mode === 'slices') {
                    const promises = files.map(file => {
                        return new Promise((resolve) => {
                            const reader = new FileReader();
                            reader.onload = (event) => {
                                const img = new Image();
                                img.onload = () => {
                                    resolve({
                                        id: Math.random().toString(36).substr(2, 9),
                                        file: file,
                                        name: file.name,
                                        cid: `${file.name.replace(/[^a-zA-Z0-9]/g, '_')}@edm.maker`,
                                        preview: event.target.result,
                                        width: img.width, height: img.height,
                                        aspectRatio: img.height / img.width,
                                        order: parseInt(file.name.match(/\d+/)?.[0] || 999)
                                    });
                                };
                                img.src = event.target.result;
                            };
                            reader.readAsDataURL(file);
                        });
                    });
                    Promise.all(promises).then(res => setImages(prev => [...prev, ...res].sort((a,b) => a.order - b.order)));
                } else {
                    const file = files[0];
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => setLongImage({ data: event.target.result, width: img.width, height: img.height, fileName: file.name });
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                }
                e.target.value = '';
            };

            const findSnapY = (y, markers) => {
                let bestY = y;
                let minDelta = SNAP_THRESHOLD;
                markers.forEach(m => {
                    if (Math.abs(y - m.yStart) < minDelta) { bestY = m.yStart; minDelta = Math.abs(y - m.yStart); }
                    if (Math.abs(y - m.yEnd) < minDelta) { bestY = m.yEnd; minDelta = Math.abs(y - m.yEnd); }
                });
                return bestY;
            };

            // 获取坐标工具函数，支持从外部开始画
            const getYFromEvent = (e) => {
                if (!longImageImgRef.current) return 0;
                const rect = longImageImgRef.current.getBoundingClientRect();
                const scale = longImage.height / rect.height;
                const rawY = (e.clientY - rect.top) * scale;
                
                // 如果正在绘制或调整，限制在编辑器范围内
                if (isDrawing || resizeTarget) {
                     if (rawY < 0) return 0;
                     if (rawY > longImage.height) return longImage.height;
                }
                
                // 钳制在 0 到 图片高度之间
                return Math.max(0, Math.min(rawY, longImage.height));
            };

            // 检查鼠标是否在图片区域内
            const isMouseInImage = (e) => {
                 if (!longImageImgRef.current) return false;
                 const rect = longImageImgRef.current.getBoundingClientRect();
                 return e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
            };

            // 查找切片调整边界（支持相邻和独立边缘）
            const findResizeBoundary = (y, e) => {
                // 仅当鼠标在图片内部时才允许调整大小
                if (e && !isMouseInImage(e)) return null;

                const sorted = [...sliceMarkers].sort((a,b) => a.yStart - b.yStart);
                
                // 1. 检查相邻切片
                for (let i = 0; i < sorted.length - 1; i++) {
                    const upper = sorted[i];
                    const lower = sorted[i+1];
                    // 判定相邻：间隙小于 2px
                    if (Math.abs(upper.yEnd - lower.yStart) < 2) {
                        if (Math.abs(y - upper.yEnd) < 10) {
                            return { type: 'dual', upper, lower };
                        }
                    }
                }

                // 2. 检查独立边缘
                for (let i = 0; i < sorted.length; i++) {
                    const slice = sorted[i];
                    
                    // 检查上边缘
                    if (Math.abs(y - slice.yStart) < 10) {
                        // 确保上方没有紧邻的切片 (如果有，应该已被上面的逻辑捕获，除非有微小误差，这里再校验一次)
                        const prevSlice = sorted[i-1];
                        if (!prevSlice || Math.abs(prevSlice.yEnd - slice.yStart) >= 2) {
                            // 计算向上调整的极限 (上一张切片的结束位置 或 0)
                            const constraintMin = prevSlice ? prevSlice.yEnd : 0;
                            // 向下调整的极限 (当前切片的结束位置 - 最小高度)
                            const constraintMax = slice.yEnd - 5; 
                            return { type: 'top', slice, constraintMin, constraintMax };
                        }
                    }

                    // 检查下边缘
                    if (Math.abs(y - slice.yEnd) < 10) {
                        // 确保下方没有紧邻的切片
                        const nextSlice = sorted[i+1];
                        if (!nextSlice || Math.abs(slice.yEnd - nextSlice.yStart) >= 2) {
                            // 向上调整的极限 (当前切片的开始位置 + 最小高度)
                            const constraintMin = slice.yStart + 5;
                            // 向下调整的极限 (下一张切片的开始位置 或 图片高度)
                            const constraintMax = nextSlice ? nextSlice.yStart : longImage.height;
                            return { type: 'bottom', slice, constraintMin, constraintMax };
                        }
                    }
                }
                
                return null;
            };

            const handleMouseDown = (e) => {
                if (editorTool !== 'slice' || !longImage) return;
                
                // 如果点击的是右键，不触发绘制或调整，交由 contextmenu 处理
                if (e.button === 2) return;

                const y = getYFromEvent(e);

                // 1. 检查是否在调整大小区域 (必须在图片内部)
                const boundary = findResizeBoundary(y, e);
                if (boundary) {
                    if (boundary.type === 'dual') {
                        setResizeTarget({ 
                            type: 'dual',
                            upperId: boundary.upper.id, 
                            lowerId: boundary.lower.id,
                            upperStart: boundary.upper.yStart, // 用于记录初始状态 (可选)
                            lowerEnd: boundary.lower.yEnd      // 用于记录初始状态 (可选)
                        });
                    } else if (boundary.type === 'top') {
                        setResizeTarget({
                            type: 'top',
                            sliceId: boundary.slice.id,
                            constraintMin: boundary.constraintMin,
                            constraintMax: boundary.constraintMax
                        });
                    } else if (boundary.type === 'bottom') {
                        setResizeTarget({
                            type: 'bottom',
                            sliceId: boundary.slice.id,
                            constraintMin: boundary.constraintMin,
                            constraintMax: boundary.constraintMax
                        });
                    }
                    setIsDrawing(false);
                    // 清除上下文菜单
                    setContextMenu(null);
                    return;
                }

                // 处理点击选择 (如果未命中任何切片，则清除选择)
                const clickedSlice = sliceMarkers.find(m => y > m.yStart && y < m.yEnd);
                if (!e.shiftKey) {
                    // 普通点击：如果点击了空白处，清除选择；如果点击了切片，选中该切片（如果尚未选中）
                    // 注意：为了支持拖拽新建，这里如果是点击切片，我们不立即 set selection，防止误触。
                    // 但是为了简单体验，点击即选中是合理的。
                    // 这里的逻辑：如果后续触发了 drawing，可以在 mouseUp 时处理 selection。
                    // 更好的方式：mousedown 时记录点击对象，mouseup 时如果没有发生位移，则判定为点击选择。
                }

                // 2. 开始绘制切片
                const sorted = [...sliceMarkers].sort((a,b) => a.yStart - b.yStart);
                const parentSlice = sorted.find(m => y > m.yStart && y < m.yEnd);
                
                // 如果起始点在已有切片内部，禁止绘制（防止入侵/重叠）
                if (parentSlice) {
                    return;
                }

                // 在空白区域 -> 新建模式（不可入侵现有切片）
                // 关键逻辑优化：如果起始点在已有切片的Y范围内（但鼠标在图片外），
                // 则自动吸附到最近的切片边界开始绘制
                
                if (!isMouseInImage(e)) {
                    // 检查是否覆盖了某个切片（因为 y 是通过 getYFromEvent 投影到图片高度上的）
                    const coveredSlice = sorted.find(m => y > m.yStart && y < m.yEnd);
                    if (coveredSlice) {
                         // 如果投影点在已有切片内，禁止绘制
                         return;
                    }
                }

                let constraint = { min: 0, max: longImage.height };
                
                // 重新计算 min/max
                let min = 0;
                let max = longImage.height;
                for (let m of sorted) {
                    if (m.yEnd <= y) min = Math.max(min, m.yEnd);
                    if (m.yStart >= y) max = Math.min(max, m.yStart);
                }
                constraint = { min, max };
                
                // 再次修正 y，确保在 min/max 之间 (可能因为吸附逻辑跳出了范围)
                if (y < min) y = min;
                if (y > max) y = max;
                
                setDrawConstraint(constraint);
                
                // 初始吸附逻辑
                let startY = y;
                if (Math.abs(y - constraint.min) < SNAP_THRESHOLD) startY = constraint.min;
                else if (Math.abs(y - constraint.max) < SNAP_THRESHOLD) startY = constraint.max;
                else startY = findSnapY(y, sliceMarkers);

                setIsDrawing(true);
                setCurrentDraw({ yStart: startY, yEnd: startY });
            };

            const handleSliceClick = (e, sliceId) => {
                e.stopPropagation(); // 防止冒泡触发背景清除
                if (editorTool === 'delete') {
                    pushHistory(sliceMarkers.filter(s => s.id !== sliceId));
                    return;
                }

                if (e.shiftKey) {
                    setSelectedSliceIds(prev => {
                        if (prev.includes(sliceId)) return prev.filter(id => id !== sliceId);
                        return [...prev, sliceId];
                    });
                } else {
                    setSelectedSliceIds([sliceId]);
                }
            };

            const handleBackgroundClick = () => {
                setSelectedSliceIds([]);
                setContextMenu(null);
            };

            // 移除右键菜单相关函数

            // 使用 Ref 存储关键状态，供全局事件监听器访问
            const stateRef = React.useRef({
                sliceMarkers: [],
                longImage: null,
                drawConstraint: null,
                currentDraw: null,
                isDrawing: false,
                resizeTarget: null
            });

            // 每次渲染更新 Ref
            React.useEffect(() => {
                stateRef.current = {
                    sliceMarkers,
                    longImage,
                    drawConstraint,
                    currentDraw,
                    isDrawing,
                    resizeTarget
                };
            });

            const handleMouseMove = (e) => {
                // 从 Ref 获取最新状态，或者直接使用当前作用域的状态
                // 注意：由于此函数每次渲染都会重新定义，所以它可以直接访问当前的 props 和 state。
                // 但是如果被绑定到 window 上，我们需要确保它能访问到最新的闭包，
                // 或者我们依赖 useEffect 的清除和重新绑定机制。
                // 鉴于 React 的性质，我们将利用 useEffect 依赖 [handleMouseMove] 来重新绑定。
                
                const { isDrawing, resizeTarget, longImage, drawConstraint, sliceMarkers } = stateRef.current;

                // 如果正在拖拽或调整大小，拦截默认行为，防止选中文字等
                if (isDrawing || resizeTarget) {
                    e.preventDefault();
                }
                
                if (!longImage) return;

                const y = getYFromEvent(e);

                if (isDrawing) {
                    let newY = y;
                    
                    // 强行限制在约束范围内
                    if (newY < drawConstraint.min) newY = drawConstraint.min;
                    if (newY > drawConstraint.max) newY = drawConstraint.max;

                    // 吸附
                    const snapY = findSnapY(newY, sliceMarkers);
                    if (Math.abs(newY - snapY) < SNAP_THRESHOLD) newY = snapY;
                    
                    setCurrentDraw(prev => ({ ...prev, yEnd: newY }));
                } else if (resizeTarget) {
                    let newY = y;
                    
                    // 调整时的约束
                    if (resizeTarget.type === 'dual') {
                         // 双向调整：限制在上下切片的最小高度
                         const upperMin = resizeTarget.upperStart + 5;
                         const lowerMax = resizeTarget.lowerEnd - 5;
                         if (newY < upperMin) newY = upperMin;
                         if (newY > lowerMax) newY = lowerMax;
                    } else {
                         // 独立调整
                         if (newY < resizeTarget.constraintMin) newY = resizeTarget.constraintMin;
                         if (newY > resizeTarget.constraintMax) newY = resizeTarget.constraintMax;
                    }
                    
                    // 吸附 (调整时也吸附)
                    const snapY = findSnapY(newY, sliceMarkers.filter(m => {
                         if (resizeTarget.type === 'dual') return m.id !== resizeTarget.upperId && m.id !== resizeTarget.lowerId;
                         return m.id !== resizeTarget.sliceId;
                    }));
                    if (Math.abs(newY - snapY) < SNAP_THRESHOLD) newY = snapY;

                    // 应用调整
                    if (resizeTarget.type === 'dual') {
                        setSliceMarkers(prev => prev.map(m => {
                            if (m.id === resizeTarget.upperId) return { ...m, yEnd: newY };
                            if (m.id === resizeTarget.lowerId) return { ...m, yStart: newY };
                            return m;
                        }));
                    } else if (resizeTarget.type === 'top') {
                        setSliceMarkers(prev => prev.map(m => 
                            m.id === resizeTarget.sliceId ? { ...m, yStart: newY } : m
                        ));
                    } else if (resizeTarget.type === 'bottom') {
                        setSliceMarkers(prev => prev.map(m => 
                            m.id === resizeTarget.sliceId ? { ...m, yEnd: newY } : m
                        ));
                    }
                } else {
                    // 仅移动鼠标：更新光标样式
                    // 只有在图片内部时才显示调整光标
                    const boundary = findResizeBoundary(y, e);
                    if (boundary) {
                        document.body.style.cursor = 'row-resize';
                    } else {
                        document.body.style.cursor = '';
                    }
                }
            };

            const handleMouseUp = () => {
                // 使用 ref 读取最新状态，因为 handleMouseUp 可能被 window 触发，闭包可能陈旧
                // 但是如果我们每次 render 都重绑，闭包就是新的。
                // 为了保险，这里读取 ref。
                const { isDrawing, currentDraw, resizeTarget, sliceMarkers } = stateRef.current;

                if (isDrawing) {
                    setIsDrawing(false);
                    // 完成绘制
                    if (currentDraw && Math.abs(currentDraw.yStart - currentDraw.yEnd) > 2) {
                        const newSlice = {
                            id: Math.random().toString(36).substr(2, 9),
                            yStart: Math.min(currentDraw.yStart, currentDraw.yEnd),
                            yEnd: Math.max(currentDraw.yStart, currentDraw.yEnd)
                        };
                        pushHistory([...sliceMarkers, newSlice]);
                        // 绘制完成后自动选中新切片
                        setSelectedSliceIds([newSlice.id]);
                    }
                    setCurrentDraw(null);
                }
                
                if (resizeTarget) {
                    setResizeTarget(null);
                    pushHistory(sliceMarkers); // 记录调整后的历史
                }
                
                document.body.style.cursor = '';
            };

            // 全局事件监听：确保鼠标移出区域后仍能响应
            React.useEffect(() => {
                if (isDrawing || resizeTarget) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        window.removeEventListener('mousemove', handleMouseMove);
                        window.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [isDrawing, resizeTarget, handleMouseMove, handleMouseUp]);

            const makeEdm = () => {
                if (!longImage || sliceMarkers.length === 0) return;
                const sorted = [...sliceMarkers].sort((a, b) => a.yStart - b.yStart);
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = () => {
                    const newImgs = sorted.map((m, i) => {
                        const w = longImage.width, h = m.yEnd - m.yStart;
                        canvas.width = w; canvas.height = h;
                        ctx.drawImage(img, 0, m.yStart, w, h, 0, 0, w, h);
                        return {
                            id: Math.random().toString(36).substr(2, 9),
                            name: `slice_${i+1}.jpg`,
                            cid: `slice_${i+1}@edm.maker`,
                            preview: canvas.toDataURL('image/jpeg', 0.9),
                            aspectRatio: h / w,
                            order: i,
                            file: { type: 'image/jpeg' }
                        };
                    });
                    setImages(newImgs);
                    setMode('slices');
                };
                img.src = longImage.data;
            };

            const exportAsEML = () => {
                if (images.length === 0) return;
                setIsExporting(true);
                const targetWidthPx = Math.round(targetWidthCm * CM_TO_PX);
                const spacers = '<div style="font-family: Calibri; font-size: 11pt; line-height: 1.2;">&nbsp;</div>'.repeat(3);
                const tableRows = images.map(img => `<tr><td align="center" style="padding:0;line-height:0;font-size:0;"><img src="cid:${img.cid}" width="${targetWidthPx}" height="${Math.round(targetWidthPx * img.aspectRatio)}" style="display:block;border:0;width:${targetWidthPx}px;vertical-align:top;"></td></tr>`).join('');
                const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body style="margin:0;padding:0;background:#ffffff;">${spacers}<table border="0" cellpadding="0" cellspacing="0" width="${targetWidthPx}" align="center" style="border-collapse:collapse;margin:0 auto;table-layout:fixed;">${tableRows}</table></body></html>`;
                const boundary = "boundary_" + Date.now();
                const encodedHTML = btoa(unescape(encodeURIComponent(html))).match(/.{1,76}/g).join("\r\n");
                let eml = [`Subject: =?UTF-8?B?${btoa(unescape(encodeURIComponent(mailInfo.subject)))}?=`, "MIME-Version: 1.0", `Content-Type: multipart/related; boundary="${boundary}"`, "X-Unsent: 1", "", `--${boundary}`, "Content-Type: text/html; charset=UTF-8", "Content-Transfer-Encoding: base64", "", encodedHTML, ""];
                images.forEach(img => {
                    eml.push(`--${boundary}`, `Content-Type: image/jpeg`, "Content-Transfer-Encoding: base64", `Content-ID: <${img.cid}>`, `Content-Disposition: inline; filename="${img.name}"`, "", img.preview.split(',')[1].match(/.{1,76}/g).join("\r\n"), "");
                });
                eml.push(`--${boundary}--`);
                const blob = new Blob([eml.join("\r\n")], { type: 'message/rfc822' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `${mailInfo.subject}.eml`; a.click();
                setIsExporting(false);
            };

            return (
                <div className="p-4 md:p-8 max-w-7xl mx-auto">
                    <header className="flex flex-col md:flex-row justify-between gap-4 mb-8">
                        <div>
                            <h1 className="text-3xl font-bold flex items-center gap-2 text-slate-800"><Icon name="Layout" className="text-blue-600" size={28} /> Outlook EDM 制作专家 <span className="text-xs bg-blue-100 text-blue-600 px-2 py-1 rounded">v2.3</span></h1>
                            <p className="text-slate-500 mt-1 text-sm">Powered by 靳晓楠00491162>ip>
                        </div>
                        <div className="flex gap-2">
                            {mode === 'long-image' && longImage && (
                                <button onClick={makeEdm} className="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-xl font-bold shadow-lg flex items-center gap-2">
                                    <Icon name="Check" size={20}/> 制作 EDM
                                </button>
                            )}
                            <button onClick={exportAsEML} disabled={images.length === 0 || isExporting} className="bg-gradient-to-r from-blue-600 to-indigo-600 text-white px-8 py-4 rounded-xl font-bold shadow-lg disabled:opacity-50 flex items-center gap-2 transition-all active:scale-95">
                                <Icon name="Send" size={20}/> {isExporting ? '处理中...' : '生成 EML 邮件'}
                            </button>
                        </div>
                    </header>

                    <div className="flex bg-white p-1 rounded-xl w-fit shadow-sm border mb-8">
                        <button onClick={() => setMode('slices')} className={`px-4 py-2 rounded-lg text-sm font-bold flex items-center gap-2 transition-all ${mode === 'slices' ? 'bg-blue-600 text-white' : 'text-slate-400'}`}><Icon name="Layout" size={16}/> 上传切片模式</button>
                        <button onClick={() => setMode('long-image')} className={`px-4 py-2 rounded-lg text-sm font-bold flex items-center gap-2 transition-all ${mode === 'long-image' ? 'bg-blue-600 text-white' : 'text-slate-400'}`}><Icon name="Crop" size={16}/> 长图切割模式</button>
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
                        <div className="lg:col-span-4 space-y-6">
                            <section className="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                                <h2 className="font-bold mb-4 flex items-center gap-2 text-slate-700"><Icon name="Mail" size={18} className="text-blue-500"/> 邮件主题</h2>
                                <input type="text" value={mailInfo.subject} onChange={(e) => setMailInfo({subject: e.target.value})} className="w-full px-3 py-2 border rounded-lg outline-none focus:ring-2 focus:ring-blue-500"/>
                            </section>

                            {mode === 'slices' && (
                                <section className="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                                    <h2 className="font-bold mb-4 flex items-center gap-2 text-slate-700"><Icon name="Settings" size={18} className="text-slate-400"/> 尺寸设置</h2>
                                    <label className="text-xs text-slate-400 block mb-1">图片显示宽度 (cm)</label>
                                    <input type="number" value={targetWidthCm} onChange={(e) => setTargetWidthCm(e.target.value)} className="w-full px-3 py-2 border rounded-lg outline-none focus:ring-2 focus:ring-blue-500"/>
                                </section>
                            )}

                            <section className="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                                <h2 className="font-bold mb-4 flex items-center gap-2 text-slate-700"><Icon name="Upload" size={18} className="text-slate-400"/> 上传素材</h2>
                                <div className="border-2 border-dashed rounded-xl p-8 text-center relative cursor-pointer hover:bg-slate-50 transition-colors">
                                    <input type="file" multiple={mode === 'slices'} accept="image/*" onChange={handleFileUpload} className="absolute inset-0 opacity-0 cursor-pointer" />
                                    <Icon name="Upload" size={24} className="mx-auto text-blue-500 mb-2"/>
                                    <p className="text-xs font-semibold text-slate-600">{mode === 'slices' ? '上传多张切片文件' : '上传一张设计长图'}</p>
                                </div>
                            </section>

                            {mode === 'long-image' && longImage && (
                                <section className="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                                    <h3 className="text-xs font-bold text-slate-400 uppercase mb-4">切片工具箱</h3>
                                    <div className="grid grid-cols-2 gap-2 mb-4">
                                        <button onClick={() => setEditorTool('slice')} className={`flex items-center justify-center gap-2 p-2 rounded-lg border text-sm font-bold ${editorTool === 'slice' ? 'bg-blue-50 border-blue-500 text-blue-600' : 'text-slate-500'}`}><Icon name="Scissors" size={16}/> 切片工具</button>
                                        <button onClick={() => setEditorTool('delete')} className={`flex items-center justify-center gap-2 p-2 rounded-lg border text-sm font-bold ${editorTool === 'delete' ? 'bg-red-50 border-red-500 text-red-600' : 'text-slate-500'}`}><Icon name="Trash2" size={16}/> 删除切片</button>
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={undo} disabled={history.length === 0} className="flex-1 border p-2 rounded-lg text-xs font-bold disabled:opacity-30"><Icon name="Undo" size={14} className="inline mr-1"/>撤销</button>
                                        <button onClick={redo} disabled={redoStack.length === 0} className="flex-1 border p-2 rounded-lg text-xs font-bold disabled:opacity-30"><Icon name="Redo" size={14} className="inline mr-1"/>重做</button>
                                    </div>
                                    <p className="text-[10px] text-slate-400 mt-4 leading-relaxed">
                                        提示：<br/>
                                        1. 支持从图片外的灰色区域开始拖拽绘制。<br/>
                                        2. 绘制高度将自动锁定并吸附至图片边缘。<br/>
                                        3. 选区将始终横贯图片左右两侧。
                                    </p>
                                </section>
                            )}
                        </div>

                        <div className="lg:col-span-8">
                            <div className="bg-white rounded-2xl shadow-sm border border-slate-200 overflow-hidden min-h-[750px] flex flex-col">
                                <div className="bg-slate-50 border-b p-4 text-center text-[10px] font-bold text-slate-400 uppercase tracking-widest flex items-center justify-center gap-2">
                                    <Icon name="Eye" size={12}/> {mode === 'slices' ? 'Outlook 发送预览' : '跨边界切片编辑器'}
                                </div>
                                
                                <div 
                                        className="flex-1 p-8 overflow-auto bg-slate-200/20 ps-slicer-viewport"
                                        onMouseDown={mode === 'long-image' ? handleMouseDown : undefined}
                                        onMouseMove={mode === 'long-image' && !isDrawing && !resizeTarget ? handleMouseMove : undefined}
                                        onClick={handleBackgroundClick}
                                    >
                                    {mode === 'slices' ? (
                                        images.length > 0 ? (
                                            <div className="flex flex-col items-center">
                                                <div className="preview-canvas w-full max-w-4xl p-6">
                                                    <div style={{ fontFamily: 'Calibri', fontSize: '11pt', lineHeight: '1.2' }}>&nbsp;</div>
                                                    <div style={{ fontFamily: 'Calibri', fontSize: '11pt', lineHeight: '1.2' }}>&nbsp;</div>
                                                    <div style={{ fontFamily: 'Calibri', fontSize: '11pt', lineHeight: '1.2' }}>&nbsp;</div>
                                                    <table border="0" cellpadding="0" cellspacing="0" align="center" style={{borderCollapse:'collapse', margin:'0 auto', width:`${Math.round(targetWidthCm * CM_TO_PX)}px`}}>
                                                        <tbody>
                                                            {images.map((img, index) => (
                                                                <tr 
                                                                    key={img.id}
                                                                    draggable
                                                                    onDragStart={(e) => handleDragStart(e, index)}
                                                                    onDragEnter={(e) => handleDragEnter(e, index)}
                                                                    onDragEnd={handleDragEnd}
                                                                    onDragOver={(e) => e.preventDefault()}
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        setSelectedSliceIds([img.id]);
                                                                    }}
                                                                    style={{cursor: 'move', transition: 'all 0.2s'}}
                                                                >
                                                                    <td align="center" style={{padding:0, lineHeight:0, fontSize:0, position:'relative'}}>
                                                                        <img 
                                                                            src={img.preview} 
                                                                            style={{display:'block', width:'100%', border:0}} 
                                                                        />
                                                                        <div className={selectedSliceIds.includes(img.id) ? 'preview-image-selected' : (selectedSliceIds.length > 0 ? 'preview-image-unselected' : '')} style={{position:'absolute', top:0, left:0, width:'100%', height:'100%', pointerEvents:'none'}}></div>
                                                                    </td>
                                                                </tr>
                                                            ))}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center justify-center h-full text-slate-300 opacity-30 pointer-events-none"><Icon name="Layout" size={64} className="mb-4"/><p>等待素材上传...</p></div>
                                        )
                                    ) : (
                                        longImage ? (
                                            <div className="flex justify-center">
                                                <div 
                                                    ref={longImageContainerRef}
                                                    className="ps-slicer-container shadow-2xl" 
                                                    style={{ width: '100%', maxWidth: '800px' }}
                                                >
                                                    <img 
                                                        ref={longImageImgRef}
                                                        src={longImage.data} 
                                                        className="w-full block pointer-events-none" 
                                                        alt="Source" 
                                                    />
                                                    {sliceMarkers.sort((a,b)=>a.yStart-b.yStart).map((m, i) => (
                                                        <div key={m.id} 
                                                            className={`ps-slice ${editorTool === 'delete' ? 'deleting' : ''} ${selectedSliceIds.includes(m.id) ? 'selected' : ''}`} 
                                                            style={{ top: `${(m.yStart / longImage.height) * 100}%`, height: `${((m.yEnd - m.yStart) / longImage.height) * 100}%` }} 
                                                            onClick={(e) => handleSliceClick(e, m.id)}
                                                        >
                                                            <div className="ps-slice-tag">{(i + 1).toString().padStart(2, '0')}</div>
                                                        </div>
                                                    ))}
                                                    {isDrawing && currentDraw && (
                                                        <div className="ps-drawing-overlay" style={{ top: `${(Math.min(currentDraw.yStart, currentDraw.yEnd) / longImage.height) * 100}%`, height: `${(Math.abs(currentDraw.yEnd - currentDraw.yStart) / longImage.height) * 100}%` }} />
                                                    )}
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center justify-center h-full text-slate-300 opacity-30 pointer-events-none"><Icon name="Crop" size={64} className="mb-4"/><p>上传长图开始切割</p></div>
                                        )
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
